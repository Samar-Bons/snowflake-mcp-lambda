# ABOUTME: SQLAlchemy models for application data including User model with constraints
# ABOUTME: Defines database schema with proper indexing, relationships, and validation rules

import uuid
from datetime import datetime, timezone
from typing import Any

from sqlalchemy import JSON, Boolean, DateTime, ForeignKey, String, Text, func
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.ext.asyncio import AsyncAttrs
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship


class Base(AsyncAttrs, DeclarativeBase):
    """Base class for all SQLAlchemy models with async support."""

    pass


class User(Base):
    """
    User model for storing user authentication and profile information.

    Includes Google OAuth integration, Snowflake configuration storage,
    and comprehensive audit fields with proper constraints.
    """

    __tablename__ = "users"

    # Primary key
    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True),
        primary_key=True,
        default=uuid.uuid4,
        comment="Unique user identifier",
    )

    # Authentication fields
    email: Mapped[str] = mapped_column(
        String(320),  # RFC 5321 email length limit
        unique=True,
        nullable=False,
        index=True,
        comment="User email address (unique)",
    )

    google_id: Mapped[str] = mapped_column(
        String(255),
        unique=True,
        nullable=False,
        index=True,
        comment="Google OAuth user ID (unique)",
    )

    # Profile fields
    name: Mapped[str] = mapped_column(
        String(255), nullable=False, comment="User display name"
    )

    picture_url: Mapped[str | None] = mapped_column(
        Text, nullable=True, comment="User profile picture URL"
    )

    # Status fields
    is_active: Mapped[bool] = mapped_column(
        Boolean, default=True, nullable=False, comment="Whether user account is active"
    )

    # Snowflake configuration (JSON storage)
    snowflake_config: Mapped[dict[str, Any] | None] = mapped_column(
        JSON, nullable=True, comment="User's Snowflake connection configuration"
    )

    # Audit fields
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        nullable=False,
        comment="Record creation timestamp",
    )

    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now(),
        nullable=False,
        comment="Record last update timestamp",
    )

    # Relationships
    query_history: Mapped[list["QueryHistory"]] = relationship(
        "QueryHistory",
        back_populates="user",
        cascade="all, delete-orphan",
        lazy="dynamic",
    )

    def __repr__(self) -> str:
        """String representation of User model."""
        return f"<User(id={self.id}, email={self.email}, name={self.name})>"

    def __init__(self, **kwargs: Any) -> None:
        """Initialize User with timezone-aware timestamps."""
        super().__init__(**kwargs)

        # Ensure timestamps are timezone-aware UTC if not provided
        now = datetime.now(timezone.utc)
        if not hasattr(self, "created_at") or self.created_at is None:
            self.created_at = now
        if not hasattr(self, "updated_at") or self.updated_at is None:
            self.updated_at = now


class QueryHistory(Base):
    """
    Query history model for storing user queries and execution results.

    Tracks natural language input, generated SQL, execution results,
    and metadata for query analytics and user experience improvement.
    """

    __tablename__ = "query_history"

    # Primary key
    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True),
        primary_key=True,
        default=uuid.uuid4,
        comment="Unique query history identifier",
    )

    # Foreign key to user
    user_id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True),
        ForeignKey("users.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
        comment="User who executed the query",
    )

    # Query content
    natural_language_input: Mapped[str] = mapped_column(
        Text,
        nullable=False,
        comment="Original natural language query from user",
    )

    generated_sql: Mapped[str] = mapped_column(
        Text,
        nullable=False,
        comment="SQL query generated by LLM",
    )

    # Execution metadata
    execution_status: Mapped[str] = mapped_column(
        String(50),
        nullable=False,
        default="pending",
        comment="Query execution status: pending, success, failed, cancelled",
    )

    execution_time_ms: Mapped[int | None] = mapped_column(
        nullable=True,
        comment="Query execution time in milliseconds",
    )

    row_count: Mapped[int | None] = mapped_column(
        nullable=True,
        comment="Number of rows returned by query",
    )

    # Results and metadata
    query_results: Mapped[dict[str, Any] | None] = mapped_column(
        JSON,
        nullable=True,
        comment="Query results in JSON format (limited for storage)",
    )

    error_message: Mapped[str | None] = mapped_column(
        Text,
        nullable=True,
        comment="Error message if query failed",
    )

    # User preferences
    is_favorite: Mapped[bool] = mapped_column(
        Boolean,
        default=False,
        nullable=False,
        comment="Whether user marked query as favorite",
    )

    custom_name: Mapped[str | None] = mapped_column(
        String(255),
        nullable=True,
        comment="Custom name given by user for the query",
    )

    # Audit fields
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        nullable=False,
        comment="Query execution timestamp",
    )

    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now(),
        nullable=False,
        comment="Record last update timestamp",
    )

    # Relationships
    user: Mapped["User"] = relationship(
        "User",
        back_populates="query_history",
        lazy="selectin",
    )

    def __repr__(self) -> str:
        """String representation of QueryHistory model."""
        return f"<QueryHistory(id={self.id}, user_id={self.user_id}, status={self.execution_status})>"

    def __init__(self, **kwargs: Any) -> None:
        """Initialize QueryHistory with timezone-aware timestamps."""
        super().__init__(**kwargs)

        # Ensure timestamps are timezone-aware UTC if not provided
        now = datetime.now(timezone.utc)
        if not hasattr(self, "created_at") or self.created_at is None:
            self.created_at = now
        if not hasattr(self, "updated_at") or self.updated_at is None:
            self.updated_at = now
